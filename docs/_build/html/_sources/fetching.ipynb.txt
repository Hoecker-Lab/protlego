{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fetching from the Fuzzle database"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First import the ProtLego module."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from protlego.all import *"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The webserver fuzzle is a useful source to find fragments shared by different folds. It uses the SCOP95 subset of the SCOP database. For each domain a Hidden Markov Model (HMM) was generated and all-against-all HMM profile comparisons with HHsearch were perfomed. The structural similarity was measured using TM-align. A final set of more than 10 million Hits have been identified and are contained in fuzzle."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can check the web here https://fuzzle.uni-bayreuth.de/2.0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1. Fetching from ID\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are several ways to fetch from the Fuzzle database, perhaps one of the easiest way is fetching by the Hit ID. \n",
    "Each Hit in fuzzle has an ID which eases its identification. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhit= fetch_id('4413706')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "protlego.database.data.Hit"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(myhit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can always get the documentation of any function or variable by using the function help()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on Hit in module protlego.database.data object:\n",
      "\n",
      "class Hit(builtins.tuple)\n",
      " |  Some of the documentation of this function was\n",
      " |  taken from the hhsuite python documentation:\n",
      " |  https://github.com/soedinglab/hh-suite/wiki\n",
      " |  as the sequence information from the Fuzzle hits\n",
      " |  come from HHsearch.\n",
      " |  The structural superimpositions were performed with\n",
      " |  TMalign:   https://zhanglab.ccmb.med.umich.edu/TM-align/\n",
      " |  \n",
      " |  =======================================================\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      Hit\n",
      " |      builtins.tuple\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __getnewargs__(self)\n",
      " |      Return self as a plain tuple.  Used by copy and pickle.\n",
      " |  \n",
      " |  __repr__(self)\n",
      " |      Return repr(self).\n",
      " |  \n",
      " |  _asdict(self)\n",
      " |      Return a new OrderedDict which maps field names to their values.\n",
      " |  \n",
      " |  _replace(_self, **kwds)\n",
      " |      Return a new Hit object replacing specified fields with new values\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Class methods defined here:\n",
      " |  \n",
      " |  _make(iterable, new=<built-in method __new__ of type object at 0x55c615dfe240>, len=<built-in function len>) from builtins.type\n",
      " |      Make a new Hit object from a sequence or iterable\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Static methods defined here:\n",
      " |  \n",
      " |  __new__(_cls, id:int, query:str, q_scop_id:str, no:int, sbjct:str, s_scop_id:str, s_desc:str, prob:float, eval:float, pval:float, score:float, ss:float, cols:int, q_start:int, q_end:int, s_start:int, s_end:int, hmm:int, ident:float, q_sufam_id:str, s_sufam_id:str, q_fold_id:str, s_fold_id:str, rmsd_pair:float, ca_pair:int, rmsd_tm_pair:float, score_tm_pair:float, ca_tm_pair:int, rmsd_tm:float, score_tm:float, ca_tm:int, q_tm_start:int, q_tm_end:int, s_tm_start:int, s_tm_end:int, q_cluster:str, s_cluster:str)\n",
      " |      Create new instance of Hit(id, query, q_scop_id, no, sbjct, s_scop_id, s_desc, prob, eval, pval, score, ss, cols, q_start, q_end, s_start, s_end, hmm, ident, q_sufam_id, s_sufam_id, q_fold_id, s_fold_id, rmsd_pair, ca_pair, rmsd_tm_pair, score_tm_pair, ca_tm_pair, rmsd_tm, score_tm, ca_tm, q_tm_start, q_tm_end, s_tm_start, s_tm_end, q_cluster, s_cluster)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  id\n",
      " |      Alias for field number 0\n",
      " |  \n",
      " |  query\n",
      " |      Alias for field number 1\n",
      " |  \n",
      " |  q_scop_id\n",
      " |      Alias for field number 2\n",
      " |  \n",
      " |  no\n",
      " |      Alias for field number 3\n",
      " |  \n",
      " |  sbjct\n",
      " |      Alias for field number 4\n",
      " |  \n",
      " |  s_scop_id\n",
      " |      Alias for field number 5\n",
      " |  \n",
      " |  s_desc\n",
      " |      Alias for field number 6\n",
      " |  \n",
      " |  prob\n",
      " |      Alias for field number 7\n",
      " |  \n",
      " |  eval\n",
      " |      Alias for field number 8\n",
      " |  \n",
      " |  pval\n",
      " |      Alias for field number 9\n",
      " |  \n",
      " |  score\n",
      " |      Alias for field number 10\n",
      " |  \n",
      " |  ss\n",
      " |      Alias for field number 11\n",
      " |  \n",
      " |  cols\n",
      " |      Alias for field number 12\n",
      " |  \n",
      " |  q_start\n",
      " |      Alias for field number 13\n",
      " |  \n",
      " |  q_end\n",
      " |      Alias for field number 14\n",
      " |  \n",
      " |  s_start\n",
      " |      Alias for field number 15\n",
      " |  \n",
      " |  s_end\n",
      " |      Alias for field number 16\n",
      " |  \n",
      " |  hmm\n",
      " |      Alias for field number 17\n",
      " |  \n",
      " |  ident\n",
      " |      Alias for field number 18\n",
      " |  \n",
      " |  q_sufam_id\n",
      " |      Alias for field number 19\n",
      " |  \n",
      " |  s_sufam_id\n",
      " |      Alias for field number 20\n",
      " |  \n",
      " |  q_fold_id\n",
      " |      Alias for field number 21\n",
      " |  \n",
      " |  s_fold_id\n",
      " |      Alias for field number 22\n",
      " |  \n",
      " |  rmsd_pair\n",
      " |      Alias for field number 23\n",
      " |  \n",
      " |  ca_pair\n",
      " |      Alias for field number 24\n",
      " |  \n",
      " |  rmsd_tm_pair\n",
      " |      Alias for field number 25\n",
      " |  \n",
      " |  score_tm_pair\n",
      " |      Alias for field number 26\n",
      " |  \n",
      " |  ca_tm_pair\n",
      " |      Alias for field number 27\n",
      " |  \n",
      " |  rmsd_tm\n",
      " |      Alias for field number 28\n",
      " |  \n",
      " |  score_tm\n",
      " |      Alias for field number 29\n",
      " |  \n",
      " |  ca_tm\n",
      " |      Alias for field number 30\n",
      " |  \n",
      " |  q_tm_start\n",
      " |      Alias for field number 31\n",
      " |  \n",
      " |  q_tm_end\n",
      " |      Alias for field number 32\n",
      " |  \n",
      " |  s_tm_start\n",
      " |      Alias for field number 33\n",
      " |  \n",
      " |  s_tm_end\n",
      " |      Alias for field number 34\n",
      " |  \n",
      " |  q_cluster\n",
      " |      Alias for field number 35\n",
      " |  \n",
      " |  s_cluster\n",
      " |      Alias for field number 36\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes defined here:\n",
      " |  \n",
      " |  __annotations__ = OrderedDict([('id', <class 'int'>), ('query', <c...'...\n",
      " |  \n",
      " |  _field_defaults = {}\n",
      " |  \n",
      " |  _field_types = OrderedDict([('id', <class 'int'>), ('query', <c...', <...\n",
      " |  \n",
      " |  _fields = ('id', 'query', 'q_scop_id', 'no', 'sbjct', 's_scop_id', 's_...\n",
      " |  \n",
      " |  _source = \"from builtins import property as _property, tupl...temgette...\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from builtins.tuple:\n",
      " |  \n",
      " |  __add__(self, value, /)\n",
      " |      Return self+value.\n",
      " |  \n",
      " |  __contains__(self, key, /)\n",
      " |      Return key in self.\n",
      " |  \n",
      " |  __eq__(self, value, /)\n",
      " |      Return self==value.\n",
      " |  \n",
      " |  __ge__(self, value, /)\n",
      " |      Return self>=value.\n",
      " |  \n",
      " |  __getattribute__(self, name, /)\n",
      " |      Return getattr(self, name).\n",
      " |  \n",
      " |  __getitem__(self, key, /)\n",
      " |      Return self[key].\n",
      " |  \n",
      " |  __gt__(self, value, /)\n",
      " |      Return self>value.\n",
      " |  \n",
      " |  __hash__(self, /)\n",
      " |      Return hash(self).\n",
      " |  \n",
      " |  __iter__(self, /)\n",
      " |      Implement iter(self).\n",
      " |  \n",
      " |  __le__(self, value, /)\n",
      " |      Return self<=value.\n",
      " |  \n",
      " |  __len__(self, /)\n",
      " |      Return len(self).\n",
      " |  \n",
      " |  __lt__(self, value, /)\n",
      " |      Return self<value.\n",
      " |  \n",
      " |  __mul__(self, value, /)\n",
      " |      Return self*value.\n",
      " |  \n",
      " |  __ne__(self, value, /)\n",
      " |      Return self!=value.\n",
      " |  \n",
      " |  __rmul__(self, value, /)\n",
      " |      Return value*self.\n",
      " |  \n",
      " |  count(...)\n",
      " |      T.count(value) -> integer -- return number of occurrences of value\n",
      " |  \n",
      " |  index(...)\n",
      " |      T.index(value, [start, [stop]]) -> integer -- return first index of value.\n",
      " |      Raises ValueError if the value is not present.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(myhit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see from the help, a hit contains lots of info stored in it. For example: the length, the probability, the domain names, and SCOP-IDs of the parents as well as the TM-align score."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "101\n",
      "81.7\n",
      "d2dfda1_1\n",
      "d1wa5a__2\n",
      "2.86\n",
      "c.2.1.5\n",
      "c.37.1.8\n",
      "0.54938\n"
     ]
    }
   ],
   "source": [
    "print(myhit.cols)\n",
    "print(myhit.prob)\n",
    "print(myhit.q_cluster)\n",
    "print(myhit.s_cluster)\n",
    "print(myhit.rmsd_tm_pair)\n",
    "print(myhit.q_scop_id)\n",
    "print(myhit.s_scop_id)\n",
    "print(myhit.score_tm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2. Search all the hits that contain a specific domain"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits=fetch_by_domain('d1wa5a_')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 9 hits belonging to 3 fold(s)"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The variable myhits could contain one or more hits (or none), depending on the promiscuity of the domain. In this case it appears in 9 hits, where overall 9 different folds are involved.\n",
    "\n",
    "From the variable myhits, we can directly retrieve a few statistical values:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2290353, 361595, 787549, 1181040, 1258170, 2081517, 4413706, 6818256, 9075069, 7536792, 7536798, 7536807, 7536816, 7536888, 7536911, 7536939, 7536971, 7536978]\n",
      "66.5555555556\n",
      "41.6616293251\n",
      "['c.2' 'c.37' 'c.91']\n"
     ]
    }
   ],
   "source": [
    "print(myhits.ids)\n",
    "print(myhits.avg_len)\n",
    "print(myhits.std_len)\n",
    "print(myhits.list_folds)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3. Fetch by parents (finding a hit between two domains)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One can also fetch by the domain names of the two parents. This type of search could also produce none, one, or several hits, as there could be query-subject and subject combinations, along with different ways to superimpose the structures in each of them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits2 = fetch_by_domains('d1wa5a_','d2dfda1')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 2 hits belonging to 2 fold(s)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function fetch_by_domains in module protlego.database.data:\n",
      "\n",
      "fetch_by_domains(domain1:str, domain2:str, prob:int=70, rmsd:float=3.0, ca_min:int=10, ca_max:int=200, score_tm_pair:float=0.3, ratio:float=1.25, diff_folds:bool=True)\n",
      "    Fetch all the hits between two parent domains\n",
      "    \n",
      "    :param domain1: The 7 letter code for one of the parents\n",
      "    :param domain2: The 7 letter code for one of the parents\n",
      "    :param prob: the minimum allowed HHsearch probability\n",
      "    :param rmsd: The maximum allowed RMSD (rmsd_tm_pair: \"RMSD for the TMalign alignment between the two domains, passing the sequence alignment as seed)\n",
      "    :param ca_min: The minimum allowed fragment length (for the TMalign alignment)\n",
      "    :param ca_max: The maximun allowed fragment length (for the TMalign alignment)\n",
      "    :param score_tm_pair: The minimum allowed TM-score (for the TMalign alignment)\n",
      "    :param ratio: the maximum ratio for the sequence and structural alignment lengths (cols / ca_tm_pair)\n",
      "    :param diff_folds: Whether to exclude hits from the same fold (True) or not (False)\n",
      "    :return: A result class obtaining the hits that fulfill these criteria\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(fetch_by_domains)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "mynewhit=myhits2[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "101\n",
      "76.2\n",
      "d1wa5a__2\n",
      "d2dfda1_1\n",
      "c.37.1.8\n",
      "c.2.1.5\n",
      "0.48058\n"
     ]
    }
   ],
   "source": [
    "print(mynewhit.cols)\n",
    "print(mynewhit.prob)\n",
    "print(mynewhit.q_cluster)\n",
    "print(mynewhit.s_cluster)\n",
    "print(mynewhit.q_scop_id)\n",
    "print(mynewhit.s_scop_id)\n",
    "print(mynewhit.score_tm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4. Fetching two groups "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There is also the possibilty to fetch between two SCOP groups, for example between two families. Other options are searching between two superfamilies or two folds."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 4.1 Fetching between two families"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this case we try a different combination, between the Flavodoxin folds, and the PBP fold:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Query from Fuzzle with 472 hits belonging to 2 fold(s)\n"
     ]
    }
   ],
   "source": [
    "myhits3=fetch_group('c.23.1.1','c.93.1.0')\n",
    "print(myhits3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As before, the variable myhits contains the hits and additional information, like the average length of the hits and the standard deviation or the folds. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hit between d2b4aa1 and d4nqra_ with probability 71.4 %\n",
      "\n",
      "78.2330508475\n",
      "14.8673772953\n",
      "['c.23' 'c.93']\n"
     ]
    }
   ],
   "source": [
    "print(myhits3.hits[0]) # printing the first hit because why not\n",
    "print(myhits3.avg_len) # average length between the hits in these two families\n",
    "print(myhits3.std_len)\n",
    "print(myhits3.list_folds)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 4.2 Fetch between two superfamilies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One can also fetch between two superfamilies. In the previous section we had 472 hits between two families belonging to these superfamilies. Presumably we will obtain now many more:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits4=fetch_group('c.23.1','c.93.1') "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 1859 hits belonging to 2 fold(s)"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 4.3 Fetch between two folds"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also search hits between two folds. Of course we can impose some criteria, like a certain probability, RMDS or or a certain minimal fragment length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits_1 = fetch_group('c.23','c.93',prob=70) # searching for hits with probability over 70% "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 4946 hits belonging to 2 fold(s)"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits_1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits_2 = fetch_group('c.23','c.93',prob=80,rmsd=3) # fetching hits with prob. over 80 and rmsd <3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 2554 hits belonging to 2 fold(s)"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits_2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits_3=fetch_group('c.23','c.93',prob=80, rmsd=3,ca_min=50) # fetching hits that besides\\\n",
    "#are larger than 50 aminoacids"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 2478 hits belonging to 2 fold(s)"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits_3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5. Fetching subspaces"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Additionally, there is the possibility to fetch a group or a single query against the rest of the database. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 5.1 All hits that contain a TIM-barrel"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With the function fetch_subspace we can obtain sets of hits that fullfil any criteria. For example all hits belonging to the TIM-barrel fold. Take into account that these functions present some default cutoffs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits5 = fetch_subspace(scop_q='c.1')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['a.1', 'a.100', 'a.101', 'a.102', 'a.108', 'a.114', 'a.118',\n",
       "       'a.121', 'a.126', 'a.127', 'a.128', 'a.13', 'a.137', 'a.140',\n",
       "       'a.144', 'a.149', 'a.15', 'a.150', 'a.152', 'a.153', 'a.156',\n",
       "       'a.157', 'a.159', 'a.16', 'a.168', 'a.174', 'a.177', 'a.178',\n",
       "       'a.179', 'a.18', 'a.182', 'a.185', 'a.186', 'a.193', 'a.199', 'a.2',\n",
       "       'a.20', 'a.204', 'a.206', 'a.21', 'a.218', 'a.219', 'a.22', 'a.222',\n",
       "       'a.229', 'a.23', 'a.237', 'a.24', 'a.244', 'a.247', 'a.248', 'a.25',\n",
       "       'a.253', 'a.254', 'a.258', 'a.26', 'a.271', 'a.272', 'a.277',\n",
       "       'a.28', 'a.284', 'a.287', 'a.29', 'a.291', 'a.293', 'a.294',\n",
       "       'a.297', 'a.298', 'a.3', 'a.30', 'a.300', 'a.301', 'a.31', 'a.32',\n",
       "       'a.34', 'a.35', 'a.36', 'a.39', 'a.4', 'a.40', 'a.41', 'a.42',\n",
       "       'a.43', 'a.45', 'a.46', 'a.47', 'a.48', 'a.5', 'a.53', 'a.55',\n",
       "       'a.56', 'a.58', 'a.59', 'a.6', 'a.60', 'a.61', 'a.64', 'a.65',\n",
       "       'a.69', 'a.7', 'a.73', 'a.74', 'a.77', 'a.8', 'a.80', 'a.81',\n",
       "       'a.86', 'a.88', 'a.89', 'a.9', 'a.92', 'a.93', 'a.95', 'a.96',\n",
       "       'b.1', 'b.101', 'b.106', 'b.11', 'b.111', 'b.121', 'b.122', 'b.124',\n",
       "       'b.129', 'b.136', 'b.137', 'b.14', 'b.143', 'b.144', 'b.159',\n",
       "       'b.163', 'b.174', 'b.176', 'b.178', 'b.19', 'b.2', 'b.22', 'b.26',\n",
       "       'b.29', 'b.31', 'b.34', 'b.35', 'b.36', 'b.38', 'b.40', 'b.43',\n",
       "       'b.45', 'b.47', 'b.49', 'b.50', 'b.51', 'b.52', 'b.53', 'b.54',\n",
       "       'b.55', 'b.59', 'b.6', 'b.60', 'b.61', 'b.62', 'b.7', 'b.71',\n",
       "       'b.72', 'b.73', 'b.80', 'b.82', 'b.84', 'b.85', 'b.87', 'b.88',\n",
       "       'b.92', 'c.1', 'c.100', 'c.101', 'c.102', 'c.103', 'c.105', 'c.107',\n",
       "       'c.108', 'c.109', 'c.110', 'c.111', 'c.112', 'c.114', 'c.115',\n",
       "       'c.116', 'c.119', 'c.12', 'c.120', 'c.121', 'c.122', 'c.123',\n",
       "       'c.124', 'c.125', 'c.127', 'c.128', 'c.129', 'c.13', 'c.131',\n",
       "       'c.133', 'c.135', 'c.136', 'c.138', 'c.14', 'c.141', 'c.144',\n",
       "       'c.145', 'c.149', 'c.15', 'c.150', 'c.151', 'c.154', 'c.155',\n",
       "       'c.16', 'c.17', 'c.18', 'c.19', 'c.2', 'c.20', 'c.23', 'c.24',\n",
       "       'c.25', 'c.26', 'c.27', 'c.28', 'c.3', 'c.30', 'c.31', 'c.32',\n",
       "       'c.33', 'c.34', 'c.36', 'c.37', 'c.38', 'c.4', 'c.41', 'c.42',\n",
       "       'c.44', 'c.45', 'c.46', 'c.47', 'c.48', 'c.49', 'c.5', 'c.50',\n",
       "       'c.51', 'c.52', 'c.53', 'c.54', 'c.55', 'c.56', 'c.57', 'c.58',\n",
       "       'c.59', 'c.6', 'c.60', 'c.61', 'c.62', 'c.65', 'c.66', 'c.67',\n",
       "       'c.68', 'c.69', 'c.7', 'c.70', 'c.71', 'c.72', 'c.73', 'c.74',\n",
       "       'c.77', 'c.78', 'c.79', 'c.8', 'c.80', 'c.82', 'c.83', 'c.84',\n",
       "       'c.85', 'c.86', 'c.87', 'c.88', 'c.89', 'c.9', 'c.90', 'c.92',\n",
       "       'c.93', 'c.94', 'c.95', 'c.96', 'c.97', 'c.98', 'd.1', 'd.10',\n",
       "       'd.100', 'd.101', 'd.104', 'd.106', 'd.108', 'd.11', 'd.110',\n",
       "       'd.111', 'd.112', 'd.113', 'd.115', 'd.116', 'd.118', 'd.120',\n",
       "       'd.122', 'd.124', 'd.125', 'd.126', 'd.128', 'd.129', 'd.13',\n",
       "       'd.130', 'd.131', 'd.133', 'd.136', 'd.139', 'd.14', 'd.140',\n",
       "       'd.141', 'd.142', 'd.144', 'd.145', 'd.146', 'd.147', 'd.15',\n",
       "       'd.150', 'd.151', 'd.153', 'd.155', 'd.157', 'd.159', 'd.16',\n",
       "       'd.160', 'd.161', 'd.162', 'd.163', 'd.164', 'd.165', 'd.166',\n",
       "       'd.168', 'd.169', 'd.17', 'd.173', 'd.175', 'd.178', 'd.18',\n",
       "       'd.184', 'd.185', 'd.186', 'd.194', 'd.197', 'd.198', 'd.2',\n",
       "       'd.201', 'd.202', 'd.205', 'd.206', 'd.21', 'd.211', 'd.212',\n",
       "       'd.213', 'd.217', 'd.218', 'd.22', 'd.224', 'd.225', 'd.227',\n",
       "       'd.230', 'd.235', 'd.236', 'd.24', 'd.241', 'd.242', 'd.243',\n",
       "       'd.247', 'd.248', 'd.25', 'd.250', 'd.254', 'd.256', 'd.259',\n",
       "       'd.26', 'd.264', 'd.267', 'd.268', 'd.273', 'd.274', 'd.276',\n",
       "       'd.277', 'd.282', 'd.283', 'd.288', 'd.290', 'd.293', 'd.3',\n",
       "       'd.304', 'd.306', 'd.31', 'd.310', 'd.311', 'd.316', 'd.319',\n",
       "       'd.32', 'd.321', 'd.326', 'd.327', 'd.328', 'd.332', 'd.335',\n",
       "       'd.340', 'd.344', 'd.346', 'd.349', 'd.350', 'd.356', 'd.358',\n",
       "       'd.361', 'd.364', 'd.365', 'd.367', 'd.368', 'd.37', 'd.370',\n",
       "       'd.379', 'd.38', 'd.381', 'd.39', 'd.390', 'd.391', 'd.4', 'd.40',\n",
       "       'd.41', 'd.42', 'd.44', 'd.45', 'd.49', 'd.50', 'd.51', 'd.52',\n",
       "       'd.54', 'd.56', 'd.58', 'd.59', 'd.6', 'd.60', 'd.64', 'd.65',\n",
       "       'd.66', 'd.67', 'd.68', 'd.7', 'd.70', 'd.73', 'd.74', 'd.75',\n",
       "       'd.76', 'd.78', 'd.79', 'd.8', 'd.80', 'd.81', 'd.82', 'd.85',\n",
       "       'd.86', 'd.87', 'd.88', 'd.9', 'd.90', 'd.91', 'd.92', 'd.93',\n",
       "       'd.94', 'd.95', 'd.96', 'd.99', 'e.10', 'e.13', 'e.19', 'e.22',\n",
       "       'e.23', 'e.24', 'e.26', 'e.3', 'e.32', 'e.37', 'e.39', 'e.51',\n",
       "       'e.52', 'e.53', 'e.6', 'e.7', 'e.74', 'e.79', 'e.8', 'e.80', 'f.1',\n",
       "       'f.17', 'f.21', 'f.23', 'f.3', 'f.31', 'f.48', 'g.18', 'g.19',\n",
       "       'g.2', 'g.3', 'g.31', 'g.32', 'g.36', 'g.37', 'g.39', 'g.40',\n",
       "       'g.41', 'g.44', 'g.46', 'g.66', 'g.72', 'g.75', 'g.81', 'g.9',\n",
       "       'g.96', 'g.97', 'g.98'],\n",
       "      dtype='<U5')"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits5.list_folds"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 5.2 fetch full universes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also fetch the whole universe setting some cutoffs, like for example probability and rmsd. All the hits that present probability over 70 % , and rsmd below 2.0, for example: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "myhits6 = fetch_subspace(prob=70,rmsd=2.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Query from Fuzzle with 95755 hits belonging to 451 fold(s)"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "myhits6"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
